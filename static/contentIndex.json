{"DM/CSS/Info":{"title":"Info","links":[],"tags":[],"content":""},"DM/Grafika/Barevný-model":{"title":"Barevný model","links":[],"tags":[],"content":"Barevný model\n\nBarevný model je matematický model popisující barvy na základě podílu jednotlivých složek, kterými mohou být vybrané základní barvy nebo jiné parametry. Množina barev definovaná daným barevným modelem se nazývá barevný prostor.\nNejznámější barevné modely jsou:\n\nRGB (Red, Green, Blue) - aditivní barevný model používaný například v digitální fotografii.\nCMYK - subtraktivní barevný model používaný pro barevný tisk.\nDalší modely zahrnují například HSV a Lab.\n\n\n\nPřehled barevných modelů\nRGB\n\nRGB (Red, Green, Blue) je aditivní barevný model, kde kombinací tří barev - červené, zelené a modré - lze získat téměř všechny barvy barevného spektra.\nVariantou je RGBA (Red, Green, Blue, Alpha) s přidaným alfa kanálem pro průhlednost.\nsRGB je standardní barevný prostor pro většinu monitorů, definuje základní RGB barvy, hodnotu gamma a teplotu bílé barvy.\nDalší variantou je Adobe RGB, s větším gamutem než sRGB, zejména v oblasti zeleno-azurové barvy.\n\nCMY a CMYK\n\nCMYK je subtraktivní barevný model, používaný především v tisku.\nObsahuje tři základní barvy - azurovou (Cyan), purpurovou (Magenta) a žlutou (Yellow), s přidáním čtvrté barvy - černé (Key black) pro zlepšení kvality a úsporu na tisku.\nBarvy vyjádřené v RGB nelze přesně zobrazit v CMYK a naopak, což vede k problémům s tiskem fotografií, zejména poklesu brilance barev.\n"},"DM/Grafika/Grafické-Formáty":{"title":"Grafické Formáty","links":["DM/Grafika/Rozlišení"],"tags":[],"content":"Grafické formáty\nGrafické formáty stanovují pravidla, podle kterých je obrázek uložen v souboru. Některé formáty mohou do souboru ukládat i další informace, např. náhled obrázku v malém Rozlišení, informace o expozici, datu a čase pořízení a podobně.\nDruhy grafických formátů\nBitmapový (rastrová grafika)\n\nObraz se skládá z jednotlivých pixelů (bodů), z nichž každý má definovánu určitou barvu.\n\nVektorový\n\nObraz se skládá z jednotlivých geometrických objektů (např. obdélník, elipsa, křivka), které mají definovanou barvu a styl obrysu a výplně. Jednotlivé objekty jsou popsány parametry obrysu, obvykle koeficienty Bézierových křivek 2. nebo 3. řádu.\n\nKomprese grafických formátů\nRozeznáváme dva základní druhy komprese grafických formátů: bezeztrátovou a ztrátovou.\nBezeztrátová komprese\n\nI po komprimaci zachovávají soubory identickou informaci s předlohou. Nedochází tak ke ztrátě kvality obrazu. Obvykle není tak účinná jako ztrátová komprese dat.\n\nZtrátová komprese\n\nPři kompresi zahazují část grafické informace. Používá se tam, kde je možné ztrátu některých informací tolerovat a kde nevýhoda určitého zkreslení je bohatě vyvážena velmi významným zmenšením souboru.\n\nZákladní grafické formáty\nRastrové formáty\nBezeztrátové\n\nBMP: Jednoduchý formát bitmapového obrázku.\nGIF (Graphic Interchange Format): Grafický formát určený pro rastrovou grafiku, umožňuje animace.\nPNG (Portable Network Graphics): Grafický formát určený pro bezeztrátovou kompresi rastrové grafiky.\nRAW: Soubor nijak neupravených digitalizovaných dat ze snímače digitálního fotoaparátu.\nDNG (Digital Negative): Nejmodernější formát tzv. digitálního negativu.\n\nZtrátové\n\nJPEG (Joint Photographic Experts Group): Standardní metoda ukládání snímků se ztrátovou kompresí.\nHEIF (High Efficiency Image File Format): Nový kontejner pro ukládání obrázků s vysokou efektivní kompresí.\nAVIF: Otevřený formát kódování podobný formátu HEIC.\n\nZtrátové i bezeztrátové\n\nJPEG XL: Formát navržený tak, aby výrazně překonal existující rastrové formáty.\nWDP (Windows Media Photo, HD Photo): Obrázkový kompresní algoritmus a souborový formát určený pro fotografie.\n\nVektorové formáty\n\nSVG (Scalable Vector Graphics): Značkovací jazyk a formát souboru, který popisuje dvojrozměrnou vektorovou grafiku pomocí XML.\n"},"DM/Grafika/Pixel":{"title":"Pixel","links":["DM/Grafika/Rozlišení"],"tags":[],"content":"Pixel\npicture element\nPředstavuje jeden svítící bod na monitoru, resp. jeden bod obrázku, charakterizovaný jasem a barvou, např. ve formátu RGB či CMYK.\nPopis\n\nBody na obrazovce tvoří čtvercovou síť a každý pixel je možné jednoznačně identifikovat podle jeho souřadnic.\nU barevných obrazovek se každý pixel skládá ze tří svítících obrazců odpovídajících základním barvám – červené, modré a zelené.\nNežádoucí efekty při zobrazování na monitoru zahrnují např. aliasing, moaré, neostrosti, mozaikové zkreslení, ztráta informací při zmenšování, zvětšování nebo otáčení obrazu apod.\n\nVelikost pixelu\n\nVelikost pixelu záleží na typu monitoru.\nU obvyklých analogových typů lze velikost pixelu měnit změnou Rozlišení.\nLCD obrazovky mají počet fyzických pixelů (tzv. nativní Rozlišení) zpravidla pevně vázaný na používané Rozlišení.\n\nBěžná rozlišení obrazovek\n\nObrazovky mají Rozlišení od zhruba 1280 × 720 (HD) po 3840 × 2160 (4K).\nVelikost jednoho pixelu může být sotva 0,3 mm.\nMaximální možné Rozlišení monitoru se udává v jednotkách „bod na palec“ (zkratka DPI z anglického dots per inch).\n\nMegapixel\n\nJeden megapixel zapisujeme je 1 milión pixelů, tj. bodů.\nOznačuje nejen počet bodů v obrázku, ale také maximální Rozlišení digitálního fotoaparátu nebo displeje.\n\nRozlišení displeje\n\nRozlišení monitoru nebo displeje je počet pixelů, které může být zobrazeno na obrazovce.\nČasto se udává jako počet sloupců (horizontálně, „X“) a počet řádků (vertikálně, „Y“).\nNejpoužívanější Rozlišení jsou:\n\n1024×768 (XGA/XVGA, eXtended),\n1280×800 (WXGA, Wide XGA, hlavně u notebooků),\n1366x768 (hlavně u notebooků)\n1600×1200 (UXGA, Ultra-eXtended)[1]\n1920x1080 FHD, Full HD nebo 1080p\n2560x1440 QHD, QuadHD nebo WQHD\n3440x1440 UWQHD, Ultra-Wide Quad HD\n\n\n\nMnoho uživatelů, zejména uživatelů CADu a hráčů video her, používá Rozlišení 1600×1200 (UXGA) nebo vyšší, pokud mají odpovídající zařízení. Pro digitální televizi a HDTV je typické vertikální Rozlišení 720 nebo 1080 řádků."},"DM/Grafika/Rastrová-grafika":{"title":"Rastrová grafika","links":["DM/Grafika/Rozlišení"],"tags":[],"content":"Rastrová grafika\nbitmapová grafika\nV rastrové grafice je celý obrázek popsán pomocí jednotlivých barevných bodů (pixelů). Body jsou uspořádány do mřížky. Každý bod má určen svou přesnou polohu a barvu v nějakém barevném modelu (např. RGB). Tento způsob popisu obrázků používá např. televize nebo digitální fotoaparát.\nKvalitu záznamu obrázku ovlivňuje především Rozlišení a barevná hloubka. Rozmístění a počet barevných bodů obvykle odpovídají zařízení, na kterém se obrázek vykresluje (monitor, tiskárna). Pokud se obrázek zobrazuje na monitoru, pak většinou stačí Rozlišení 72 DPI, pro tisk na tiskárně 300 DPI.\nPro převod obrazových předloh (klasické fotografie, kreseb a dalších) do rastrové grafiky slouží skener nebo digitální fotoaparát.\nNevýhody rastrové grafiky\n\nZměna velikosti (zvětšování nebo zmenšování) vede ke zhoršení obrazové kvality obrázku.\nZejména zvětšování obrázku je možné jen v omezené míře, neboť při větším zvětšení je na výsledném obrázku patrný rastr.\nPoměrně velké nároky na paměťové zdroje (při vysokém Rozlišení a barevné hloubce velikost obrázku dosahuje i jednotek megabytů, v profesionální grafice se běžně operuje i s podklady o desítkách megabytů).\n\nVýhody rastrové grafiky\n\nPřirozená volba pro digitální fotografii (a některé další typy grafiky).\nPořízení obrázku je velmi snadné například pomocí fotoaparátu nebo pomocí skeneru\n\nFormáty\nPoužívané formáty grafických souborů dělíme na nekomprimované a komprimované, komprimované pak na formáty s bezeztrátovou či ztrátovou kompresí:\n\nBMP (Bitmap): Jednoduchý formát pro ukládání nekomprimovaných obrázků, často používaný v operačních systémech Windows.\nGIF (Graphics Interchange Format): Formát vhodný pro obrázky s omezeným počtem barev, často používaný pro animace a obrázky s průhledným pozadím na webových stránkách.\nJPEG (Joint Photographic Experts Group): Velmi rozšířený formát pro komprimované fotografie, který umožňuje volbu úrovně komprese a tedy i kvality obrazu. Často používaný pro fotografie na webu a ve sdílených souborech.\nJPEG 2000: Vylepšená verze formátu JPEG, která poskytuje lepší kompresi a kvalitu obrazu, ale není tak široce podporována jako původní JPEG.\nJPEG XL: Moderní formát vyvinutý pro efektivní kompresi obrazových dat při zachování vysoké kvality obrazu a podpory pro různé funkce, jako je například progresivní načítání.\nPCX: Starší formát používaný pro rastrovou grafiku, který byl často používán v minulosti v počítačových hrách a dalších aplikacích.\nPNG (Portable Network Graphics): Formát vhodný pro webové obrázky, který podporuje průhlednost a zachování kvality bez ztráty (bezeztrátová komprese).\nTIFF (Tagged Image File Format): Formát často používaný v profesionální fotografii a grafice, který podporuje různé typy datových kompresí a barevných prostorů.\nWebP: Moderní formát vyvinutý společností Google, který nabízí efektivní kompresi a podporu pro animace a průhlednost. Často využívaný pro obrázky na webu s cílem zlepšit rychlost načítání stránek.\n"},"DM/Grafika/Rozlišení":{"title":"Rozlišení","links":[],"tags":[],"content":"Rozlišení\nRozlišení (anglicky resolution) monitoru nebo displeje je počet pixelů (nebo maximální rozlišení obrazu), které může být zobrazeno na obrazovce (monitoru). Tento pojem se občas používá i u videa, zaměnitelně se slovem rozměr. Udává se jako počet sloupců (též bodů na šířku či horizontální rozlišení, „X“) – to se uvádí jako první – a počet řádků (bodů na výšku, vertikální rozlišení, „Y“). Méně často se používá pojem barevné rozlišení, které vyjadřuje bitovou hloubku (potažmo počet barev) daného zobrazení.\nMezi nejčastější rozlišení posledních let patří:\n\nu monitorů stolních počítačů: 1920 × 1080 (Full HD), 1920 × 1200, 2560 × 1440 (QHD), 3440 × 1440, 3840 × 2160 (4K)\nu notebooků: 1920 × 1080 (Full HD) či 3840 × 2160 (4K)\nu tabletů: 1280 × 720 (HD) nebo 1280 × 800, 2048 × 1536, 2560 × 1440 (QHD)\nu chytrých telefonů: 320 × 480, 480 × 800, 540 × 960 (qHD), 1280 × 720 (HD), 1920 1080 (Full HD), u nejdražších 3840 × 2160 (4K)\nu televizí: 1280 × 720 (HD), 1920 × 1080 (Full HD) a 3840 × 2160 (4K)\nv profesionálních grafických/postprodukčních studiích: 1920 × 1080 (Full HD), 2K, 4K\n"},"DM/Grafika/Vektorová-grafika":{"title":"Vektorová grafika","links":["DM/Grafika/Pixel"],"tags":[],"content":"Vektorová grafika\nVektorový obrázek je složen ze základních, přesně definovaných útvarů, jako jsou body, přímky, křivky a mnohoúhelníky.\nVýhody\n\nJe v ní možné libovolné zmenšování nebo zvětšování obrázku beze ztráty kvality (viz ukázka v úvodu článku).\nJe možné pracovat s každým objektem v obrázku odděleně.\nVýsledná paměťová náročnost obrázku je u jednolitých barevných obrázků menší, než při použití rastrového zápisu (Např. černé kolečko se zapíše jako kruh o daném poloměru vyplněný černou barvou – tedy 3 informace, zatímco u bitmapy by bylo zapotřebí definovat každý Pixel zvlášť, přitom pořád dokola téměř stejnou informací – Pixel barvy #000000 o souřadnici [x,y], Pixel barvy #000000 o souřadnici [x+1,y], Pixel barvy #000000 o souřadnici [x+2,y], atd.).\n\nNevýhody\n\nOproti rastrové grafice zpravidla složitější pořízení obrázku. V rastrové grafice lze obrázek snadno pořídit pomocí fotoaparátu nebo skeneru.\nPřekročí-li složitost grafického objektu určitou mez, začne být vektorová grafika náročnější na operační paměť a procesor (“Mikroprocesor”) než grafika bitmapová.\nNehodí se na zápis složitých barevných ploch, například fotografie.\n\nPoužití\nVektorová grafika se používá zejména pro počítačovou sazbu, tvorbu ilustrací, diagramů, logotypů, nebo při tvorbě flashových animací. Pro práci s vektorovou grafikou se používají vektorové editory (např. Adobe Illustrator, CorelDRAW, Inkscape nebo Zoner Callisto 5).\nFormáty vektorové grafiky\n\n.eps, .ps – PostScript\n.pdf – Portable Document Format\n.ai – Adobe Illustrator Artwork\n.cdr – Corel Draw\n.svg – Scalable Vector Graphics\n.zmf – Zoner Callisto\n"},"DM/HTML/Info":{"title":"Info","links":[],"tags":[],"content":""},"DM/Info":{"title":"Info","links":[],"tags":[],"content":""},"DM/PHP/Info":{"title":"Info","links":[],"tags":[],"content":""},"DM/Web/Info":{"title":"Info","links":[],"tags":[],"content":""},"DM/Zvuk/Formát-kódování-audia":{"title":"Formát kódování audia","links":[],"tags":[],"content":"Formát kódování audia\nDefinice a příklady\n\nFormát kódování audia (někdy též formát komprese audia) je formát obsahu pro ukládání nebo přenos digitálního audia, používaný mimo jiné v digitální televizi, digitálním rádiu a audio a video souborech.\nPříklady formátů kódování audia jsou MP3, AAC, Vorbis, FLAC a Opus.\n\nAudio kodek\n\nKonkrétní softwarová nebo hardwarová implementace schopná komprese a dekomprese do a z daného formátu kódování audia se nazývá audio kodek.\nPříkladem audio kodeku je LAME, který softwarově implementuje kódování a dekódování audia do a z formátu MP3.\n\nStandardy a specifikace\n\nNěkteré formáty kódování audia jsou popsány detailní technickou specifikací nebo standardizovány.\nSpecifikace a standardy jsou napsány a schváleny standardizační organizací a známy jako standardy kódování audia.\nPojem „standard“ se někdy kromě formálních standardů používá i pro de facto standardy.\n\nKontejnery a metadata\n\nAudio obsah zakódovaný v určitém formátu kódování audia je obvykle zapouzdřen v kontejneru obsahujícím metadata.\nMP3 soubory jsou výjimkou, neobsahují kontejner a metadata jsou přidávána jako nestandardní rozšíření.\n\nVztah k videu a multimediálním kontejnerům\n\nVe video souborech je zakódovaný audio obsah spojen s videem uvnitř multimediálního kontejneru.\n\nAlgoritmy a komprese\n\nFormát kódování audia neurčuje všechny algoritmy, které mají použít kodeky implementující daný formát.\nDůležitou součástí ztrátové audio komprese je odstraňování informací podle psychoakustického modelu.\n\nTypy formátů\n\nExistují bezeztrátové, ztrátové a nekomprimované formáty kódování audia.\n\nBezeztrátové, ztrátové a nekomprimované formáty\n\nBezeztrátové formáty zachovávají původní informace a jsou dekódovatelné do své původní podoby.\nZtrátové formáty dále redukují data na úkor trvalé ztráty informace.\nBěžní uživatelé často používají ztrátové formáty pro jejich praktičnost, ale existují i bezeztrátové formáty s větší velikostí.\nNěkdy se používají i nekomprimované formáty jako pulzně kódová modulace.\n"},"DM/Zvuk/Zvuk":{"title":"Zvuk","links":[],"tags":[],"content":"Zvuk\nZvuk je mechanické vlnění v látkovém prostředí, které je schopno vyvolat sluchový vjem. Frekvence tohoto vlnění, které je člověk schopen vnímat, jsou značně individuální a leží v intervalu přibližně 16 Hz až 20 000 Hz. Mechanické vlnění mimo tento frekvenční rozsah sluchový vjem nevyvolává, přesto se někdy také označuje jako zvuk.\nFrekvenci nižší než 16 Hz má infrazvuk, slyší jej např. sloni. Frekvenci vyšší než 20 kHz má ultrazvuk, který mohou vnímat např. psi, delfíni či netopýři. Děje, které jsou spojeny se vznikem zvuku, jeho šířením a vnímáním, se nazývají akustika a stejný název má i věda, která tyto děje zkoumá."},"DM/Zvuk/Zvuková-karta":{"title":"Zvuková karta","links":[],"tags":[],"content":"Zvuková karta\nZvuková karta je rozšiřující karta počítače, která umožňuje vstup a výstup zvukového signálu, ovládaná softwarově.\nObsah zvukové karty\n\nZvukový čip: Provádí digitálně-analogový převod záznamu.\nVýstup: Většinou 3,5mm jack-sluchátkový konektor.\nLine in: Konektor pro připojení externího zdroje zvukového signálu.\nMikrofonový vstup: Konektor pro přímé připojení mikrofonu.\nMIDI a GamePort konektor: Pro připojení MIDI zařízení a herního vybavení.\n\nDigitalizace zvuku\n\nVzorkování: Záznam signálu pomocí vzorků v časových intervalech.\nVzorkovací frekvence: 11,025 kHz (telefonní kvalita), 22,05 kHz (rádio kvalita), 44,1 kHz (CD kvalita), 48,0 kHz, 96,0 kHz.\nPočet bitů na vzorek: 8, 16, nebo 24.\n\nDalší funkce\n\nCD-ROM mechanika: Dříve propojená s IDE rozhraním, dnes zbytečná díky moderním rozhraním.\nAudio kabel: Propojuje CD-ROM mechaniku se zvukovou kartou, ale většina přehrávačů se obejde bez něj.\n"},"DM/Zvuk/Záznam-zvuku":{"title":"Záznam zvuku","links":[],"tags":[],"content":"Záznam zvuku\nZáznamem zvuku se rozumí vytváření audiozáznamu, trvanlivé mechanické, magnetické nebo optické stopy zvukových vln, kterou lze při reprodukci opakovaně proměňovat ve zvukový signál.\nPoužití\n\nNejčastěji pro hudbu, zpěv, řeč a jiné zvuky.\nKultura, zábava, dokumentace, studium jazyků, registrace letu a další účely.\n\nTypy záznamu a reprodukce\nMechanické\n\nNahrávání: Pohyb membrány přenášený na rycí jehlu.\nReprodukce: Jehla snímá profil drážky a rozeznívá membránu.\n\nElektromagnetické\n\nNahrávání: Pohyb membrány převáděn na elektrický proud.\nReprodukce: Přečtený elektrický signál rozechvívá reproduktorovou membránu.\n\nOptické\n\nDetaily nezahrnuty.\n\nAnalogový vs. Digitální záznam\nAnalogový\n\nNahrávání: Mechanický (rycí jehla) nebo elektromagnetický (záznamová hlava).\nReprodukce: Mechanický (jehla) nebo elektromagnetický (magnetická snímací hlava).\n\nDigitální\n\nNahrávání: Vzorkování zvuku vyšší frekvencí, číselné hodnoty tlaku vzduchu se zaznamenávají na elektronických pamětech.\nReprodukce: Z číselných údajů se vytváří spojitý analogový signál.\n\nPřednosti digitálního záznamu\n\nVětší odolnost proti mechanickému opotřebení a poškození.\nKvalita reprodukce se s časem a opakovaným přehráváním nezhoršuje.\n"},"DTS/Databáze-rychlý-obecný-poznámky":{"title":"Databáze rychlý obecný poznámky","links":[],"tags":[],"content":"Databáze rychlý obecný poznámky\nEntity, atributy, relace\n\nEntity: Objekt nebo věc v databázi, která je identifikovatelná a má význam pro danou oblast. Například, v databázi knihovny mohou být entity jako „Kniha“, „Autor“, „Čtenář“.\nAtributy: Vlastnosti nebo charakteristiky entity. Pro entitu „Kniha“ mohou být atributy jako „Název“, „Autor“, „ISBN“, „Rok vydání“.\nRelace: Vztahy mezi entitami. Například, relace mezi „Knihou“ a „Autorem“ může být „Napsal“.\n\nDMM (Data Manipulation and Management)\n\n\ncreate_database: Vytvoří novou databázi.\nCREATE DATABASE nazev_databaze;\n\n\ndrop_database: Odstraní existující databázi.\nDROP DATABASE nazev_databaze;\n\n\ncreate_table: Vytvoří novou tabulku v databázi.\nCREATE TABLE nazev_tabulky (\n    sloupec1 datatype,\n    sloupec2 datatype,\n    ...\n);\n\n\ndrop_table: Odstraní tabulku z databáze.\nDROP TABLE nazev_tabulky;\n\n\nalter_table: Upraví strukturu existující tabulky (např. přidání nebo odstranění sloupce).\nALTER TABLE nazev_tabulky ADD sloupec1 datatype;\nALTER TABLE nazev_tabulky DROP COLUMN sloupec1;\n\n\ncreate_index: Vytvoří index pro zrychlení dotazů na tabulku.\nCREATE INDEX nazev_indexu ON nazev_tabulky (sloupec1, sloupec2);\n\n\nAtributy - DDL (Data Definition Language)\n\n\ninteger - celočíselný typ\n\n\ntinyint: Malé celé číslo (1 bajt)\n\n\nsmallint: Malé celé číslo (2 bajty)\n\n\nmediumint: Středně velké celé číslo (3 bajty)\n\n\nvarchar - alfanumerický řetězec proměnné délky\n\n\n    VARCHAR(255)\n\ndate - datum\n\n    DATE\n\ntimestamp - unix timestamp, měřený od 1.1.1970 v sekundách\n\n    TIMESTAMP\n\nfloat - desetinná čísla s jednoduchou přesností\n\n    FLOAT\n\ndouble - desetinná čísla s dvojitou přesností\n\n    DOUBLE\n\ncurrency - měna (závisí na databázovém systému, jak je měna implementována)\n\nDML (Data Manipulation Language)\n\n\nINSERT - vloží nový záznam do tabulky\nINSERT INTO nazev_tabulky (sloupec1, sloupec2) VALUES (hodnota1, hodnota2);\n\n\nLOAD - načte data do tabulky (různé varianty, např. z externího souboru)\nLOAD DATA INFILE &#039;soubor.csv&#039; INTO TABLE nazev_tabulky;\n\n\nUPDATE - aktualizuje existující záznamy\nUPDATE nazev_tabulky SET sloupec1 = hodnota1 WHERE podminka;\n\n\nDELETE - smaže záznamy z tabulky\nDELETE FROM nazev_tabulky WHERE podminka;\n\n\nTRUNCATE - smaže všechny záznamy z tabulky a resetuje počítadla\nTRUNCATE TABLE nazev_tabulky;\n\n\nSELECT\n\n\nSELECT - vybere data z tabulky\nSELECT * FROM nazev_tabulky;\n\n\nNOW - vrátí aktuální datum a čas\nSELECT NOW();\n\n\naliasy - zástupné znaky, které usnadňují práci s dotazy\nSELECT sloupec1 AS alias1 FROM nazev_tabulky;\n\n\nORDER BY - třídí výsledky podle určitého sloupce\nSELECT * FROM nazev_tabulky ORDER BY sloupec1;\n\n\nGROUP BY - seskupuje výsledky podle určitého sloupce\nSELECT sloupec1, COUNT(*) FROM nazev_tabulky GROUP BY sloupec1;\n\n\nHAVING - podmínka aplikovaná na seskupená data\nSELECT sloupec1, COUNT(*) FROM nazev_tabulky GROUP BY sloupec1 HAVING COUNT(*) &gt; 1;\n\n\nSpojení (Joins)\n\n\nINNER JOIN - vrací záznamy, které mají odpovídající hodnoty v obou tabulkách\nSELECT * FROM tabulka1 INNER JOIN tabulka2 ON tabulka1.sloupec = tabulka2.sloupec;\n\n\nLEFT (OUTER) JOIN - vrací všechny záznamy z levé tabulky a odpovídající záznamy z pravé tabulky\nSELECT * FROM tabulka1 LEFT JOIN tabulka2 ON tabulka1.sloupec = tabulka2.sloupec;\n\n\nRIGHT (OUTER) JOIN - vrací všechny záznamy z pravé tabulky a odpovídající záznamy z levé tabulky\nSELECT * FROM tabulka1 RIGHT JOIN tabulka2 ON tabulka1.sloupec = tabulka2.sloupec;\n\n\nFULL (OUTER) JOIN - vrací všechny záznamy, které mají odpovídající hodnoty v obou tabulkách, a všechny záznamy z obou tabulek, které nemají odpovídající hodnoty\nSELECT * FROM tabulka1 FULL OUTER JOIN tabulka2 ON tabulka1.sloupec = tabulka2.sloupec;\n\n\nIntegrita\n\nReferenční integrita: Zajišťuje, že vztahy mezi tabulkami jsou zachovány. Například cizí klíč (foreign key) v jedné tabulce musí odpovídat primárnímu klíči (primary key) v jiné tabulce.\nCREATE TABLE objednavky (\n    objednavka_id INT PRIMARY KEY,\n    zakaznik_id INT,\n    FOREIGN KEY (zakaznik_id) REFERENCES zakaznici(zakaznik_id)\n);\n\n"},"PRG/Algoritmizace/Info":{"title":"Info","links":[],"tags":[],"content":""},"PRG/Info":{"title":"Info","links":[],"tags":[],"content":""},"PRG/Java/Datové-typy-Javy":{"title":"Datové typy Javy","links":["PRG/Java/Proměnné-Javy"],"tags":[],"content":"Datové typy Javy\n\nJavovské typy se dělí na dvě skupiny:\nPrimitivní (neobjektový přístup)\n\nCeločíselné\nReálné\nZnakové\nLogické\n\n\nReferenční (objektový přístup)\n\nŘetězce\n\n\n\nPrimitivní datové typy\nCeločíselné typy\n\nnejpoužívanějším je int\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDatový typRozsahRozsahbyte1 bajt-128 až 127short2 bajty-32,768 až 32,767int4 bajty-2,147,483,648 až 2,147,483,647long8 bajtů-9,223,372,036,854,775,808 až 9,223,372,036,854,775,807\nReálné datové typy\n\nJako desetinný separátor se vždy používá tečka!\nPři použití typu float musíme ve zdrojovém kódu psát sufix F\n\nfloat f = 3.14F;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDatový typRozsahPřesnostfloat4 bajty7 decimálních číslicdouble8 bajtů15 decimálních číslic\nZnakový typ\n\nJe pouze jeden – char\nMá velikost 16 bitů\nVyužívání kódování UNICODE\nNa znaky se díváme jako na celá čísla → využíváme stejné operátory jako u celočíselného datového typu\nZnakové konstanty se zapisují několika způsoby:\n\nJeden znak, který se píše do apostrofů\n\nPř. &#039;A&#039;\n\n\nEscape sekvence (tj. speciální znaky)\n\nPř. &#039;\\n&#039;\n\n\nPosloupnost znaků \\‘uXXXX, kde XXXX představuje kód znaku v kódování UNICODE\n\nPř. &#039;\\u000A&#039; (=nový řádek), &#039;\\u0159&#039; (= ř)\n\n\n\n\n\nLogický typ\n\nPoužívá se typ boolean o velikosti 1 bit\nMůže nabývat dvou hodnot\n\nlogická konstanta true (= pravda, logická 1)\nfalse (= nepravda, logická 0)\n\n\nPoužívá se hodně u podmínek\n\nboolean jeSplnenTest = false;\nboolean jeVetsiCislo = cislo &gt; 5;\nReferenční datové typy\n\nReferenční datové typy jsou složitější než primitivní a nemají omezenou délku\nIdentifikátor tohoto typu začíná vždy velkým písmenem!\nTypickým zástupce je datový typ String\n\nSlouží pro ukládání řetězců → musí být ohraničeny uvozovkami\nLze používat diakritika\n\n\n\nString jmeno = &quot;Jan&quot;;\nString pozdrav = &quot;Dobrý den&quot;;\n\nSpojení dvou a více řetězců do jednoho\n\npomocí spojovacího operátoru +\n\n\n\nString s1 = &quot;eps&quot;;\nString s2 = &quot;2&quot;;\nString s3 = s1 + s2;      //vytvori retezec eps2\n\nŘetězce lze spojovat i s hodnotami jiného typu\n\nint x = 42;\nString s = &quot;Odpověď je &quot; + x;   //vytvori retezec Odpověď je 42\nPřetypování\n\nProměnné Javy lze přiřadit pouze hodnotu stejného typu\nChceme-li přiřadit jiný typ, je nutné přetypování (typová konverze)\nJméno datového typu zapisujeme do kulatých závorek před proměnnou, kterou chceme přetypovat\n\nchar c = &#039;A&#039;;\nint i = (int) c;\nchar d = (char) i;\n\nPozor!\nPřetypování má nejvyšší prioritu → celý výraz je třeba dát do závorek\n\n(double) i + j     //přetypuje se jen i\n(double) (i+j)     //správně\n\nImplicitní – proběhne automaticky\n\nJe to konverze z typů s nižším rozsahem na typy s vyšším rozsahem\nbyte → short → int → long → float → double\n\n\n\nint i = 5;\ndouble d = i;     //d bude 5.0\n\nExplicitní – je nutno zapsat do programu\n\nOpačný směr, tj. z vyššího rozsahu na nižší → může dojít ke ztrátě nebo změně původní hodnoty → musí se zapsat operátor přetypování!\n\n\ndouble → float → long → int → short → byte\n\ndouble d = 5.253;\nint i = (int) d;      //i bude 5"},"PRG/Java/Datové-typy":{"title":"Datové typy","links":["PRG/Java/Proměnné"],"tags":[],"content":"Datové typy\n\nJavovské typy se dělí na dvě skupiny:\nPrimitivní (neobjektový přístup)\n\nCeločíselné\nReálné\nZnakové\nLogické\n\n\nReferenční (objektový přístup)\n\nŘetězce\n\n\n\nPrimitivní datové typy\nCeločíselné typy\n\nnejpoužívanějším je int\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDatový typRozsahRozsahbyte1 bajt-128 až 127short2 bajty-32,768 až 32,767int4 bajty-2,147,483,648 až 2,147,483,647long8 bajtů-9,223,372,036,854,775,808 až 9,223,372,036,854,775,807\nReálné datové typy\n\nJako desetinný separátor se vždy používá tečka!\nPři použití typu float musíme ve zdrojovém kódu psát sufix F\n\nfloat f = 3.14F;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDatový typRozsahPřesnostfloat4 bajty7 decimálních číslicdouble8 bajtů15 decimálních číslic\nZnakový typ\n\nJe pouze jeden – char\nMá velikost 16 bitů\nVyužívání kódování UNICODE\nNa znaky se díváme jako na celá čísla → využíváme stejné operátory jako u celočíselného datového typu\nZnakové konstanty se zapisují několika způsoby:\n\nJeden znak, který se píše do apostrofů\n\nPř. &#039;A&#039;\n\n\nEscape sekvence (tj. speciální znaky)\n\nPř. &#039;\\n&#039;\n\n\nPosloupnost znaků \\‘uXXXX, kde XXXX představuje kód znaku v kódování UNICODE\n\nPř. &#039;\\u000A&#039; (=nový řádek), &#039;\\u0159&#039; (= ř)\n\n\n\n\n\nLogický typ\n\nPoužívá se typ boolean o velikosti 1 bit\nMůže nabývat dvou hodnot\n\nlogická konstanta true (= pravda, logická 1)\nfalse (= nepravda, logická 0)\n\n\nPoužívá se hodně u podmínek\n\nboolean jeSplnenTest = false;\nboolean jeVetsiCislo = cislo &gt; 5;\nReferenční datové typy\n\nReferenční datové typy jsou složitější než primitivní a nemají omezenou délku\nIdentifikátor tohoto typu začíná vždy velkým písmenem!\nTypickým zástupce je datový typ String\n\nSlouží pro ukládání řetězců → musí být ohraničeny uvozovkami\nLze používat diakritika\n\n\n\nString jmeno = &quot;Jan&quot;;\nString pozdrav = &quot;Dobrý den&quot;;\n\nSpojení dvou a více řetězců do jednoho\n\npomocí spojovacího operátoru +\n\n\n\nString s1 = &quot;eps&quot;;\nString s2 = &quot;2&quot;;\nString s3 = s1 + s2;      //vytvori retezec eps2\n\nŘetězce lze spojovat i s hodnotami jiného typu\n\nint x = 42;\nString s = &quot;Odpověď je &quot; + x;   //vytvori retezec Odpověď je 42\nPřetypování\n\nProměnné lze přiřadit pouze hodnotu stejného typu\nChceme-li přiřadit jiný typ, je nutné přetypování (typová konverze)\nJméno datového typu zapisujeme do kulatých závorek před proměnnou, kterou chceme přetypovat\n\nchar c = &#039;A&#039;;\nint i = (int) c;\nchar d = (char) i;\n\nPozor!\nPřetypování má nejvyšší prioritu → celý výraz je třeba dát do závorek\n\n(double) i + j     //přetypuje se jen i\n(double) (i+j)     //správně\n\nImplicitní – proběhne automaticky\n\nJe to konverze z typů s nižším rozsahem na typy s vyšším rozsahem\nbyte → short → int → long → float → double\n\n\n\nint i = 5;\ndouble d = i;     //d bude 5.0\n\nExplicitní – je nutno zapsat do programu\n\nOpačný směr, tj. z vyššího rozsahu na nižší → může dojít ke ztrátě nebo změně původní hodnoty → musí se zapsat operátor přetypování!\n\n\ndouble → float → long → int → short → byte\n\ndouble d = 5.253;\nint i = (int) d;      //i bude 5"},"PRG/Java/For-cyklus-Javy":{"title":"For cyklus Javy","links":[],"tags":[],"content":"Cyklus For Javy\nPokud přesně víte, kolikrát chcete projít blok kódu, použijte místo cyklu while cyklus for:\nSyntaxe\nfor (příkaz 1; příkaz 2; příkaz 3) {\n  // blok kódu, který se má provést\n}\nVýrok 1 se provede (jednou) před provedením bloku kódu.\nVýrok 2 definuje podmínku pro provedení bloku kódu.\nVýrok 3 se provede (pokaždé) po provedení bloku kódu.\nNíže uvedený příklad vypíše čísla 0 až 4:\nPříklad\nfor (int i = 0; i &lt; 5; i++) {\n  System.out.println(i);\n}\nVysvětlení příkladu\nPříkaz 1 nastaví proměnnou před začátkem cyklu (int i = 0).\nPříkaz 2 definuje podmínku pro spuštění cyklu (i musí být menší než 5). Pokud je podmínka pravdivá, cyklus se spustí znovu, pokud je nepravdivá, cyklus se ukončí.\nPříkaz 3 zvyšuje hodnotu (i++) pokaždé, když byl blok kódu v cyklu proveden.\n\nDalší příklad\nTento příklad vypíše pouze sudé hodnoty mezi 0 a 10:\nPříklad\nfor (int i = 0; i &lt;= 10; i = i + 2) {\n  System.out.println(i);\n}\n\nVnořené smyčky\nJe také možné umístit cyklus do jiného cyklu. Tomu se říká vnořený cyklus.\n”Vnitřní cyklus” se provede jednou za každou iteraci “vnějšího cyklu”:\nPříklad\n// Vnější cyklus\nfor (int i = 1; i &lt;= 2; i++) {\n  System.out.println(&quot;Vnější: &quot; + i); // Provede se 2krát\n  \n  // Vnitřní cyklus\n  for (int j = 1; j &lt;= 3; j++) {\n    System.out.println(&quot; Vnitřní: &quot; + j); // Provede se 6krát (2 * 3).\n  }\n} "},"PRG/Java/For-Each-cyklus-Javy":{"title":"For-Each cyklus Javy","links":[],"tags":[],"content":"For-Each cyklus Javy\nExistuje smyčka “for-each”, která se používá výhradně k procházení prvků v poli:\nSyntaxe\nfor (typ variableName : arrayName) {\n  // blok kódu, který se provede\n}\nNásledující příklad vypíše všechny prvky pole auta pomocí cyklu “for-each”:\nPříklad\nString[] auta = {&quot;Volvo&quot;, &quot;BMW&quot;, &quot;Ford&quot;, &quot;Mazda&quot;};\nfor (String i : auta) {\n  System.out.println(i);\n}"},"PRG/Java/Hlavní-program-Javy":{"title":"Hlavní program Javy","links":[],"tags":[],"content":"Hlavní program Javy\n\nTvoří hlavní metoda main()\nPo spuštění programu je vyvolána jako první\nMusí se vždy takto jmenovat a musí být v programu vždy uvedena\nMusí být umístěna v nějaké třídě, která je označena jako public\nMusí mít přesně tuto podobu:\n\npublic static void main(String[] args){\n\t//tělo metody main\n}"},"PRG/Java/Hlavní-program":{"title":"Hlavní program","links":[],"tags":[],"content":"Hlavní program\n\nTvoří hlavní metoda main()\nPo spuštění programu je vyvolána jako první\nMusí se vždy takto jmenovat a musí být v programu vždy uvedena\nMusí být umístěna v nějaké třídě, která je označena jako public\nMusí mít přesně tuto podobu:\n\npublic static void main(String[] args){\n\t//tělo metody main\n}"},"PRG/Java/If...-Else-Javy":{"title":"If... Else Javy","links":[],"tags":[],"content":"If… Else Javy\nPomocí podmínek můžete provádět různé akce pro různá rozhodnutí.\nPříkaz if\nPříkaz if slouží k zadání bloku kódu Javy, který se provede, pokud je podmínka pravdivá.\nSyntaxe\nif (podmínka) {\n  // blok kódu, který se provede, pokud je podmínka true\n}\nVšimněte si, že if je psáno malými písmeny. Velká písmena (If nebo IF) vyvolají chybu.\nPříklad\nV následujícím příkladu testujeme dvě hodnoty, abychom zjistili, zda je 20 větší než 18. Pokud je podmínka pravdivá, vypíšeme nějaký text:\nif (20 &gt; 18) {\n  System.out.println(&quot;20 je větší než 18&quot;);\n}\nPříklad\nMůžeme také testovat proměnné:\nint x = 20;\nint y = 18;\nif (x &gt; y) {\n  System.out.println(&quot;x je větší než y&quot;);\n}\nVysvětlení příkladu\nVe výše uvedeném příkladu používáme dvě proměnné, x a y, abychom otestovali, zda je x větší než y (pomocí operátoru &gt;). Protože x je 20 a y je 18 a my víme, že 20 je větší než 18, vypíšeme na obrazovku, že “x je větší než y”.\nPříkaz else\nPříkaz else slouží k zadání bloku kódu, který se provede, pokud je podmínka false.\nSyntaxe\nif (podmínka) {\n  // blok kódu, který se provede, pokud je podmínka true\n} else {\n  // blok kódu, který se provede, pokud je podmínka nepravdivá\n}\nPříklad\nint cas = 20;\nif (cas &lt; 18) {\n  System.out.println(&quot;Dobrý den.&quot;);\n} else {\n  System.out.println(&quot;Dobrý večer.&quot;);\n}\n// Vypíše &quot;Dobrý večer.&quot;\n \nVysvětlení příkladu\nVe výše uvedeném příkladu je čas (20) větší než 18, takže podmínka je false. Z tohoto důvodu přejdeme k podmínce else a vypíšeme na obrazovku “Dobrý večer”. Pokud by byl čas menší než 18, program by vypsal “Dobrý den”.\nPříkaz else if\nPříkaz else if slouží k zadání nové podmínky, pokud je první podmínka false.\nSyntaxe\nif (podminka1) {\n  // blok kódu, který se provede, pokud je podmínka1 true\n} else if (podminka2) {\n  // blok kódu, který se provede, pokud je podmínka1 false a podmínka2 true\n} else {\n  // blok kódu, který se provede, pokud je podmínka1 nepravdivá a podmínka2 nepravdivá\n}\nPříklad\nint cas = 22;\nif (cas &lt; 10) {\n  System.out.println(&quot;Dobré ráno.&quot;);\n} else if (cas &lt; 18) {\n  System.out.println(&quot;Dobrý den.&quot;);\n} else {\n  System.out.println(&quot;Dobrý večer.&quot;);\n}\n// Vypíše &quot;Dobrý večer.&quot;\n \nVysvětlení příkladu\nVe výše uvedeném příkladu je čas (22) větší než 10, takže první podmínka je false. Další podmínka v příkazu else if je také false, takže přejdeme k podmínce else, protože podminka1 a podminka2 jsou obě false - a vypíšeme na obrazovku “Dobrý večer”.\nKdyby však bylo 14 hodin, náš program by vypsal “Dobrý den”.\nZkrácené if else\nExistuje také zkrácený zápis if else, který je známý jako tercinální operátor, protože se skládá ze tří operandů.\nLze jej použít k nahrazení více řádků kódu jediným řádkem a nejčastěji se používá k nahrazení jednoduchých příkazů if else:\nSyntaxe\nproměnná = (podmínka) ? výrazTrue : výrazFalse;\nPříklad\nMísto zápisu:\nint time = 20;\nif (time &lt; 18) {\n  System.out.println(&quot;Dobrý den.&quot;);\n} else {\n  System.out.println(&quot;Dobrý večer.&quot;);\n}\nMůžete jednoduše napsat:\nint time = 20;\nString result = (time &lt; 18) ? &quot;Dobrý den.&quot; : &quot;Dobrý večer.&quot;;\nSystem.out.println(result);"},"PRG/Java/Java":{"title":"Java","links":["PRG/Základní-info-o-PRG/Programovací-jazyk"],"tags":[],"content":"Java\n\nvznik v roce 1995 ve společnosti Sun Microsystems\npojmenován podle indonéské odrůdy kávy\n\nVýhody jazyka\n\nObjektově orientovaný Programovací jazyk\nZdarma\nNezávislý na platformě\nSilná typovost jazyka\nVyužití v prostředí jazyku\nMožnost práce s multimédii\nVysoký výkon\nBezpečnost\n\nNevýhody jazyka\n\nHardwarová náročnost\nRychlý vývoj jazyka\n\nV současné době, ale již jsou základní funkce standardizovány\n\n\nRozsáhlost jazyka\nSložitější práce se standardním vstupem/výstupem\nPoněkud nižší rychlost běhu programu (čím vyšší verze jazyka, tím je zpomalení nižší)\nDélka zápisu kódu\n\nPoužití jazyka\n\nDesktopové a webové aplikace\nMobilní aplikace pro operační systém Android\nServletů (tj. programy běžící na serverech)\nPoužívá se na komplexní aplikace a to hlavně ve finančním a telekomunikačním sektoru\nV ČR jsou stovky firem, které Javu používají\n\nNapř. Oracle, Home Credit, O2, Česká Spořitelna, IBM, T-Mobile, ZEBRA, DHL, …\n\n\n\nHistorie jazyka\n\n1990 – Green Project\n1992 – OAK, použitý na PDA\n1995 – první verze Javy, Java pro Netscape\n1996 – Java 1.0, další podpora Javy\n1997 – Java 1.1, Java Web Server\n1999 – XML, NetBeans (Praha), J2SE, J2EE, J2ME\n2004 – Java SE 5\n2006 – Java SE 6\n\nEdice jazyka\nJava Standard Edition (Java SE)\n\nje vlastně Java, tak jak byla vyvíjena od první verze a postupně rozšiřována.\nKdyž firma Sun Microsystems zavedla termín platforma Java, bylo třeba původní kolekci API odlišit od ostatních verzí, proto vzniklo toto označení.\n\nJava Enterprise Edition (Java EE)\n\nje sada knihoven do Java SE určených pro vývoj a provoz podnikových aplikací a informačních systémů\n\nJava Micro Edition (Java ME)\n\nBěží v SIM kartách, pračkách a dalších elektronických zařízeních\n\nDistribuce jazyka\n\nPoužívání Javy pro běžný vývoj (i komerční) je zdarma\nRedistribuce javového běhového prostředí je možná zdarma\nRedistribuce javového vývojového prostředí je dovolena/omezena konkrétními licenčními podmínkami\nDříve vyvíjela společnost Sun → dnes společnost Oracle\n\nImplementace jazyka\nPro spuštění aplikací\n\nAplikací je zapotřebí JRE (Java Runtime Environment) = běhové prostředí obsahující virtuální stroj\n\nPro vývoj aplikací\n\nJe zapotřebí JDK (Java Development Kit), které obsahuje knihovny a nástroje pro vývojáře\nPokročilé vývojové nástroje již mají implementováno\n\nVývojová prostředí\n\nEclipse\nNetBeans\nJBuilder\nIntelliJ IDEA\nBlueJ\nGreenfoot\naj.\n\nKomponenty jazyka Java\nProgramovací jazyk Java (Java Language Definition)\n\nSyntaxe a sémantika jazyka\n\nJava Virtual Machine (JVM)\n\nVirtuální stroj\n\nJava API (základní knihovna tříd)\n\nKnihovny a SW komponenty → nástroje pro práci se soubory, DB, řetězci, grafikou apod.\nJsou sdružovány do balíčku tzv. packages\n\nZpracování programu\n\nProgram je tvořen jedním nebo několika zdrojovými soubory s příponou .java\nZdrojové soubory se přeloží kompilátorem javac do mezikódu (bajtový kód)\n\nJe nezávislý na konkrétním HW a SW vybavení počítače\nPřekladem ze souboru .java vznikne nový soubor .class → tento soubor může být spuštěn pouze na JVM\n\n\nJavovský virtuální stroj (JVM) provádí převod bajtového kódu do strojového kódu příslušného procesoru → tento proces se nazývá interpretace\nPřeklad do bajtového kódu je proveden pouze jednou, interpretace při každém spuštění programu\nBajtový kód lze dekompilovat a získat zpět zdrojový kód původního programu → zdrojový kód by neměl obsahovat žádné citlivé informace (např. hesla)\n.jar\n\nSpustitelný java soubor (ekvivalence .exe souboru)\nVytváří se explicitně přes příkazový řádek nebo v nabídce vývojového prostředí\n\n\n\nPrvní program v Javě\npublic class PrvniProgram{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(“Hello world!“);\n\t}\n}\nVysvětlivky:\n\nTřída\nMetoda (funkce) – první řádek se nazývá hlavička metody\nPříkaz – musí končit středníkem\n\nKonvence a syntaxe zápisu\n\nSoubor se zdrjovým kódem musí mít název shodný s názvem třídy a příponu .java\n\nViz příklad PrvniProgram.java\n\n\nTřídy se vždy píší s prvním velkým písmenem\nKaždá metoda musí mít za názvem závorky ()\nPro ukončení každého příkazu se používá oddělovač středník\n\nJeden příkaz lze umístit na více řádků → někdy lépe čitelné\n\n\nSkupinu dvou a více příkazů můžeme uzavřít do bloku kódu (příkazy se uzavřou mezi složené závorky, za závorku nepíšeme středník)\nVnořené úseky kódu se odsazují – nemá vliv na běh programu, ale zvyšuje čitelnost programu\nJava důsledně rozlišuje malá a velká písmena (case sensitive)!!\n"},"PRG/Java/Komentáře-Javy":{"title":"Komentáře Javy","links":[],"tags":[],"content":"Komentáře Javy\n\nPomáhají vyznat se ve zdrojovém kódu\nDoporučení – komentovat ihned při vytváření úseků kódů, ne „až na to někdy budu mít čas“\nV Javě máme 3 typy\nJednořádkový\n\nZačíná // a platnost je do konce řádku\n\n\n\n utrata = pocetPiv * 28; //kolik jsem zaplatil\n\nBlokový\n\nZačíná znaky /* a až do výskytu znaků */ je vše komentář\nLze komentovat i v rámci několika řádků\nPíše se vždy před komentovaným kódem\n\n\n\n/*\ninkrementace proměnné i,\nprotože to algoritmus vyžaduje\n*/\ni++;\n\nDokumentační\n\nZačíná znaky /** a končí znaky */\nPoužívá se pro automatické generování dokumentace programem javadoc.exe\n\n\n"},"PRG/Java/Komentáře":{"title":"Komentáře","links":[],"tags":[],"content":"Komentáře\n\nPomáhají vyznat se ve zdrojovém kódu\nDoporučení – komentovat ihned při vytváření úseků kódů, ne „až na to někdy budu mít čas“\nV Javě máme 3 typy\nJednořádkový\n\nZačíná // a platnost je do konce řádku\n\n\n\n utrata = pocetPiv * 28; //kolik jsem zaplatil\n\nBlokový\n\nZačíná znaky /* a až do výskytu znaků */ je vše komentář\nLze komentovat i v rámci několika řádků\nPíše se vždy před komentovaným kódem\n\n\n\n/*\ninkrementace proměnné i,\nprotože to algoritmus vyžaduje\n*/\ni++;\n\nDokumentační\n\nZačíná znaky /** a končí znaky */\nPoužívá se pro automatické generování dokumentace programem javadoc.exe\n\n\n"},"PRG/Java/Konvence-a-syntaxe-zápisu-identifikátorů-Javy":{"title":"Konvence a syntaxe zápisu identifikátorů Javy","links":["PRG/Java/Java","PRG/Java/Proměnné-Javy"],"tags":[],"content":"Konvence a syntaxe zápisu identifikátorů Javy\n\nJava důsledně rozlišuje malá a velká písmena! (case sensitive)\n\nPř. prvni.java není to samé jako Prvni.java\n\n\nidentifikátor musí začínat písmenem, podtržítkem nebo $\n\n(pozn.: ale poslední dvě jmenované nedoporučuji)\n\n\nNázvy nesmí obsahovat diakritiku a mezeru\nPokud název tvoří více slov, začíná každé slovo velkým písmenem kvůli lepší čitelnosti\n\nPř. pocetSlov, druheJmeno, …\nTento styl se označuje jako Velbloudí notace\n(anglicky Camel Case, stylizováno jako camelCase)\n\n\nAlternativní zápis pomocí hadí notace\n\nPř. pocet_slov, druhe_jmeno\n\n\n\n\n\nTřídy a rozhraní\n\nZačíná vždy velkým písmenem a ostatní písmena jsou malá (př. String)\nTřída se musí jmenovat stejně jako soubor, ve kterém je uložena!\n\n\nMetody a Proměnné Javy\n\nZačíná malým písmenem (př. pocet, start())\nMetoda se od Proměnné Javy liší tím, že metody mají za jménem uvedeny vždy kulaté závorky\n\n\nKonstanty\n\nPouze velká písmena, ve víceslovných je oddělovačem podtržítko (př. PI, MAX_VALUE)\n\n\nBalíky\n\nPouze malá písmena, ve složených názvech je oddělovačem tečka (př.\njava.util)\n\n\n\n\n\nJako identifikátory se nesmí používat následující klíčová slova:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nabstractcontinuefornewswitchassertpackagesynchronizeddefaultgotobooleandoifprivatethisbreakelseimportpublicthrowbyteenumimplementsprotectedthrowscasedoubleinstanceofreturntransientcatchextendsintshorttrycharfinalinterfacestaticvoidclassfinallylongstrictfpvolatileconstfloatnativesuperwhile"},"PRG/Java/Konvence-a-syntaxe-zápisu-identifikátorů":{"title":"Konvence a syntaxe zápisu identifikátorů","links":["PRG/Java/Java","PRG/Java/Proměnné"],"tags":[],"content":"Konvence a syntaxe zápisu identifikátorů\n\nJava důsledně rozlišuje malá a velká písmena! (case sensitive)\n\nPř. prvni.java není to samé jako Prvni.java\n\n\nidentifikátor musí začínat písmenem, podtržítkem nebo $\n\n(pozn.: ale poslední dvě jmenované nedoporučuji)\n\n\nNázvy nesmí obsahovat diakritiku a mezeru\nPokud název tvoří více slov, začíná každé slovo velkým písmenem kvůli lepší čitelnosti\n\nPř. pocetSlov, druheJmeno, …\nTento styl se označuje jako Velbloudí notace\n(anglicky Camel Case, stylizováno jako camelCase)\n\n\nAlternativní zápis pomocí hadí notace\n\nPř. pocet_slov, druhe_jmeno\n\n\n\n\n\nTřídy a rozhraní\n\nZačíná vždy velkým písmenem a ostatní písmena jsou malá (př. String)\nTřída se musí jmenovat stejně jako soubor, ve kterém je uložena!\n\n\nMetody a Proměnné\n\nZačíná malým písmenem (př. pocet, start())\nMetoda se od Proměnné liší tím, že metody mají za jménem uvedeny vždy kulaté závorky\n\n\nKonstanty\n\nPouze velká písmena, ve víceslovných je oddělovačem podtržítko (př. PI, MAX_VALUE)\n\n\nBalíky\n\nPouze malá písmena, ve složených názvech je oddělovačem tečka (př.\njava.util)\n\n\n\n\n\nJako identifikátory se nesmí používat následující klíčová slova:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nabstractcontinuefornewswitchassertpackagesynchronizeddefaultgotobooleandoifprivatethisbreakelseimportpublicthrowbyteenumimplementsprotectedthrowscasedoubleinstanceofreturntransientcatchextendsintshorttrycharfinalinterfacestaticvoidclassfinallylongstrictfpvolatileconstfloatnativesuperwhile"},"PRG/Java/Načtení-hodnoty-Javy":{"title":"Načtení hodnoty Javy","links":[],"tags":[],"content":"Načtení hodnoty Javy\n\nExistuje více způsobů načtení dat, jedna z možností:\n\nNačtení hodnoty typu double zajistí metoda nextDouble();\nNačtení hodnoty typu int zajistí metoda nextInt();\nNačtení hodnoty typu String zajistí metoda nextLine();\n\n\n\nScanner sc = new Scanner(System.in);\nint vstup = sc.nextInt();\nSystem.out.println(&quot;Načtená hodnota: &quot; + vstup);\n\nna začátek kódu před názvem třídy je potřeba vložit následující příkaz (ten naimportuje knihovnu pro práci se vstupem)\n\nimport java.util.Scanner;"},"PRG/Java/Načtení-hodnoty":{"title":"Načtení hodnoty","links":[],"tags":[],"content":"Načtení hodnoty\n\nExistuje více způsobů načtení dat, jedna z možností:\n\nNačtení hodnoty typu double zajistí metoda nextDouble();\nNačtení hodnoty typu int zajistí metoda nextInt();\nNačtení hodnoty typu String zajistí metoda nextLine();\n\n\n\nScanner sc = new Scanner(System.in);\nint vstup = sc.nextInt();\nSystem.out.println(&quot;Načtená hodnota: &quot; + vstup);\n\nna začátek kódu před názvem třídy je potřeba vložit následující příkaz (ten naimportuje knihovnu pro práci se vstupem)\n\nimport java.util.Scanner;"},"PRG/Java/Operátory-Javy":{"title":"Operátory Javy","links":[],"tags":[],"content":"Operátory Javy\nOperátory se používají k provádění operací na proměnných a hodnotách.\nAritmetické operátory\nAritmetické operátory se používají k provádění běžných matematických operací.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperátorNázevPopisPříklad+SčítáníSčítá dvě hodnotyx + y-OdčítáníOdečte jednu hodnotu od druhéx - y*NásobeníNásobení dvou hodnotx * y/DěleníDělí jednu hodnotu druhoux / y%ModulusVrátí zbytek po děleníx % y++InkrementaceZvyšuje hodnotu proměnné o 1++x--SníženíSníží hodnotu proměnné o 1--x\nOperátory přiřazení\nOperátory přiřazení se používají k přiřazení hodnot proměnným.\nV následujícím příkladu použijeme operátor přiřazení = k přiřazení hodnoty 10 proměnné x:\nint x = 10;\nOperátor přiřazení sčítání += přidává hodnotu do proměnné:\nint x = 10;\nx += 5;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperátorPříkladStejné jako=x = 5x = 5+=x += 3x = x + 3-=x -= 3x = x - 3*=x *= 3x = x * 3/=x /= 3x = x / 3%=x %= 3x = x % 3&amp;=x &amp;= 3x = x &amp; 3|=x |= 3x = x | 3^=x ^= 3x = x ^ 3&gt;&gt;=x &gt;&gt;= 3x = x &gt;&gt; 3&lt;&lt;=x &lt;&lt;= 3x = x &lt;&lt; 3\nOperátory porovnávání\nOperátory porovnávání slouží k porovnání dvou hodnot (nebo proměnných). To je v programování důležité, protože nám to pomáhá hledat odpovědi a rozhodovat se.\nNávratová hodnota porovnání je buď true, nebo false. Tyto hodnoty se nazývají logické hodnoty\nV následujícím příkladu použijeme operátor větší než &gt;, abychom zjistili, zda je 5 větší než 3:\nint x = 5;\nint y = 3;\nSystem.out.println(x &gt; y); // vrátí true, protože 5 je větší než 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperátorNázevPříklad==Rovná sex == y!=Není rovnox != y&gt;Větší nežx &gt; y&lt;Méně nežx &lt; y&gt;=Větší nebo rovnox &gt;= y&lt;=Menší nebo rovnox &lt;= y\nLogické operátory\nPomocí logických operátorů můžete také testovat pravdivé nebo nepravdivé hodnoty.\nLogické operátory se používají k určení logiky mezi proměnnými nebo hodnotami:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperátorNázevPopisPříklad&amp;&amp;Logické aVrací true, pokud jsou oba příkazy pravdivéx &lt; 5 &amp;&amp; x &lt; 10|Logické neboVrátí pravdu, pokud je jeden z výroků pravdivýx &lt; 5 | x &lt; 4!Logické neObrátí výsledek, vrátí nepravdu, pokud je výsledek pravdivý!(x &lt; 5 &amp;&amp; x &lt; 10)"},"PRG/Java/Pole-Javy":{"title":"Pole Javy","links":[],"tags":[],"content":"Pole Javy\nPole se používají k uložení více hodnot do jedné proměnné, místo aby se pro každou hodnotu deklarovaly samostatné proměnné.\nChcete-li deklarovat pole, definujte typ proměnné pomocí čtvercových závorek:\nString[] auta;\nNyní jsme deklarovali proměnnou, která obsahuje pole řetězců. Chcete-li do ní vložit hodnoty, můžete je umístit do seznamu odděleného čárkami, který se nachází uvnitř složených závorek:\nString[] auta = {&quot;Volvo&quot;, &quot;BMW&quot;, &quot;Ford&quot;, &quot;Mazda&quot;};\nChcete-li vytvořit pole celých čísel, můžete napsat:\nint[] mojeCisla = {10, 20, 30, 40};\n\nPřístup k prvkům pole\nK prvku pole můžete přistupovat odkazem na indexové číslo.\nTento příkaz přistupuje k hodnotě prvního prvku v auta:\nPříklad\nString[] auta = {&quot;Volvo&quot;, &quot;BMW&quot;, &quot;Ford&quot;, &quot;Mazda&quot;};\nSystem.out.println(auta[0]);\n// Výstupy Volvo\nPoznámka: Indexy pole začínají 0: [0] je první prvek. [1] je druhý prvek atd.\n\nZměna prvku pole\nChcete-li změnit hodnotu konkrétního prvku, odkažte se na číslo indexu:\nPříklad\nauta[0] = &quot;Opel&quot;;\nPříklad\nString[] auta = {&quot;Volvo&quot;, &quot;BMW&quot;, &quot;Ford&quot;, &quot;Mazda&quot;};\nauta[0] = &quot;Opel&quot;;\nSystem.out.println(auta[0]);\n// Nyní vypíše Opel místo Volvo\n\nDélka pole\nChcete-li zjistit, kolik prvků má pole, použijte vlastnost length:\nPříklad\nString[] auta = {&quot;Volvo&quot;, &quot;BMW&quot;, &quot;Ford&quot;, &quot;Mazda&quot;};\nSystem.out.println(auta.length);\n// Výstup 4"},"PRG/Java/Proměnné-Javy":{"title":"Proměnné Javy","links":[],"tags":[],"content":"Proměnné Javy\n\nProměnná je pojmenované místo v paměti\nSlouží k uchování hodnoty za běhu programu\nKaždá proměnná má jméno a datový typ\n\nPomocí jména se na proměnnou odkazujeme\nDatový typ udává, jaké hodnoty můžeme do proměnné ukládat (př. reálná čísla, řetězce, …)\n\n\n\n\nZápis\n\nKonvence a syntaxe zápisu\n\nNázev začíná vždy malým písmenem nebo podtržítkem\nNázev nesmí začínat číslovkou (ale později v názvu již může být použita)\nV případě, že je název tvořen více slovy, začíná každé slovo velkým písmenem\nPř. pocet2, pocetPrvku\n\n\nDeklarace\n\nProměnnou je nutno před prvním použitím deklarovat (definovat), tj. stanovit jméno a datový typ (do paměti se uloží automaticky)\n\n\n\nint cislo;\nchar znak1, znak2;\nPřiřazení hodnoty\n\nHodnotu uložíme do proměnné operátorem přiřazení → proměnná = výraz (hodnota);\n\ncislo = 42;\n\nPrvní přiřazení do proměnné nazýváme inicializace\nInicializaci proměnné je možné spojit s její deklarací\n\nint cislo = 42;\n\nInicializace musí proběhnout před prvním čtením!\n\nint i;\nint j;\nj = i + 2;//chyba při překladu\nDeklarace proměnných\n\nDoporučení\nKaždá proměnná by měla být deklarována na samostatné řádce a okomentovaná\n\ndouble celkemPlat; //celkový plat\n\nPozn.: Je povoleno deklarovat více proměnných na jeden řádek\n\nint i, j;\n\nKaždá explicitně inicializovaná proměnná by měla být deklarována samostatně\n\nint i;\nint j = 1;\n\nMezi deklaracemi proměnných a dalšími příkazy je vhodné mít prázdnou řádku kvůli přehlednosti\n\nOperátor přiřazení\n\nPozor na následující terminologii\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVýrazi * 2 + 3Přiřazeníj = i * 2 + 3Příkazj = i * 2 + 3;\n\nTo znamená:\n\nVýraz má vždy hodnotu (číselnou, znakovou nebo pravdivostní)\nPřiřazení je výraz a jeho hodnotou je hodnota přiřazená levé straně\nPřiřazení se stává příkazem, je-li ukončeno středníkem\n\n\n"},"PRG/Java/Proměnné":{"title":"Proměnné","links":[],"tags":[],"content":"Proměnné\n\nProměnná je pojmenované místo v paměti\nSlouží k uchování hodnoty za běhu programu\nKaždá proměnná má jméno a datový typ\n\nPomocí jména se na proměnnou odkazujeme\nDatový typ udává, jaké hodnoty můžeme do proměnné ukládat (př. reálná čísla, řetězce, …)\n\n\n\n\nZápis\n\nKonvence a syntaxe zápisu\n\nNázev začíná vždy malým písmenem nebo podtržítkem\nNázev nesmí začínat číslovkou (ale později v názvu již může být použita)\nV případě, že je název tvořen více slovy, začíná každé slovo velkým písmenem\nPř. pocet2, pocetPrvku\n\n\nDeklarace\n\nProměnnou je nutno před prvním použitím deklarovat (definovat), tj. stanovit jméno a datový typ (do paměti se uloží automaticky)\n\n\n\nint cislo;\nchar znak1, znak2;\nPřiřazení hodnoty\n\nHodnotu uložíme do proměnné operátorem přiřazení → proměnná = výraz (hodnota);\n\ncislo = 42;\n\nPrvní přiřazení do proměnné nazýváme inicializace\nInicializaci proměnné je možné spojit s její deklarací\n\nint cislo = 42;\n\nInicializace musí proběhnout před prvním čtením!\n\nint i;\nint j;\nj = i + 2;//chyba při překladu\nDeklarace proměnných\n\nDoporučení\nKaždá proměnná by měla být deklarována na samostatné řádce a okomentovaná\n\ndouble celkemPlat; //celkový plat\n\nPozn.: Je povoleno deklarovat více proměnných na jeden řádek\n\nint i, j;\n\nKaždá explicitně inicializovaná proměnná by měla být deklarována samostatně\n\nint i;\nint j = 1;\n\nMezi deklaracemi proměnných a dalšími příkazy je vhodné mít prázdnou řádku kvůli přehlednosti\n\nOperátor přiřazení\n\nPozor na následující terminologii\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVýrazi * 2 + 3Přiřazeníj = i * 2 + 3Příkazj = i * 2 + 3;\n\nTo znamená:\n\nVýraz má vždy hodnotu (číselnou, znakovou nebo pravdivostní)\nPřiřazení je výraz a jeho hodnotou je hodnota přiřazená levé straně\nPřiřazení se stává příkazem, je-li ukončeno středníkem\n\n\n"},"PRG/Java/Switch-Javy":{"title":"Switch Javy","links":[],"tags":[],"content":"Switch Javy\nMísto psaní mnoha příkazů if..else můžete použít příkaz switch.\nPříkaz switch vybere jeden z mnoha bloků kódu, který se má provést:\nSyntaxe\nswitch(výraz) {\n  case x:\n    // blok kódu\n    break;\n  case y:\n    // blok kódu\n    break;\n  výchozí:\n    // blok kódu\n}\nTakto to funguje:\n\nVýraz switch se vyhodnotí jednou.\nHodnota výrazu se porovná s hodnotami jednotlivých case.\nPokud dojde ke shodě, provede se příslušný blok kódu.\nKlíčová slova break a default jsou nepovinná a budou popsána později v této kapitole.\n\nNásledující příklad používá číslo dne v týdnu pro výpočet názvu dne v týdnu:\nPříklad\nint den = 4;\nswitch (den) {\n  case 1:\n    System.out.println(&quot;Pondělí&quot;);\n    break;\n  case 2:\n    System.out.println(&quot;Úterý&quot;);\n    break;\n  případ 3:\n    System.out.println(&quot;Středa&quot;);\n    break;\n  případ 4:\n    System.out.println(&quot;Čtvrtek&quot;);\n    break;\n  případ 5:\n    System.out.println(&quot;Pátek&quot;);\n    break;\n  případ 6:\n    System.out.println(&quot;Sobota&quot;);\n    break;\n  case 7:\n    System.out.println(&quot;Neděle&quot;);\n    break;\n}\n// Výpis &quot;čtvrtek&quot; (den 4)\n\nKlíčové slovo break\nKdyž Java dosáhne klíčového slova break, přeruší blok přepínačů.\nTím se zastaví provádění dalšího kódu a testování případů uvnitř bloku.\nKdyž je nalezena shoda a úloha je hotova, je čas na break. Další testování již není potřeba.\nPřerušení může ušetřit spoustu času při provádění, protože “ignoruje” provádění celého zbytku kódu v bloku switch.\n\n\nKlíčové slovo default\nKlíčové slovo default určuje nějaký kód, který se má spustit, pokud neexistuje shoda případů:\nPříklad\nint den = 4;\nswitch (den) {\n  case 6:\n    System.out.println(&quot;Dnes je sobota&quot;);\n    break;\n  case 7:\n    System.out.println(&quot;Dnes je neděle&quot;);\n    break;\n  výchozí:\n    System.out.println(&quot;Těšíme se na víkend&quot;);\n}\n// Výpis &quot;Těšíme se na víkend&quot;.\nVšimněte si, že pokud je výchozí příkaz použit jako poslední příkaz v bloku switch, nepotřebuje break."},"PRG/Java/Terminálový-výstup-Javy":{"title":"Terminálový výstup Javy","links":[],"tags":[],"content":"Terminálový výstup Javy\n\nTisk provede metoda System.out.print();\n\nint i = 5;\nSystem.out.print(i); //vytiskne hodnotu 5\n\nPokud chceme vytisknout více proměnných nebo i nějaký řetězec → spojujeme znaménkem +\n\nSystem.out.print(„Číslo „ + i + „ je kladné“);\n\nPokud chceme za výpisem odřádkovat\n\nPoužijeme metodu println() místo print()\n\n\n\nSystem.out.println(„Číslo „ + i + „ je kladné“);\n\n\n\nMetoda print() a znak \\n\n\n\n\nSystem.out.print(„Číslo „ + i + „ je kladné\\n“);\n\nPrázdný řádek vložíme zavoláním metody System.out.println(); bez jakéhokoli argumentu (parametru)\n"},"PRG/Java/Terminálový-výstup":{"title":"Terminálový výstup","links":[],"tags":[],"content":"Terminálový výstup\n\nTisk provede metoda System.out.print();\n\nint i = 5;\nSystem.out.print(i); //vytiskne hodnotu 5\n\nPokud chceme vytisknout více proměnných nebo i nějaký řetězec → spojujeme znaménkem +\n\nSystem.out.print(„Číslo „ + i + „ je kladné“);\n\nPokud chceme za výpisem odřádkovat\n\nPoužijeme metodu println() místo print()\n\n\n\nSystem.out.println(„Číslo „ + i + „ je kladné“);\n\n\n\nMetoda print() a znak \\n\n\n\n\nSystem.out.print(„Číslo „ + i + „ je kladné\\n“);\n\nPrázdný řádek vložíme zavoláním metody System.out.println(); bez jakéhokoli argumentu (parametru)\n"},"PRG/Java/While-cyklus-Javy":{"title":"While cyklus Javy","links":[],"tags":[],"content":"While cyklus Javy\nCykly mohou provádět blok kódu, dokud je splněna zadaná podmínka.\nCykly jsou užitečné, protože šetří čas, snižují počet chyb a činí kód čitelnějším.\n\nCyklus while prochází blokem kódu tak dlouho, dokud je zadaná podmínka pravdivá:\nSyntaxe\nwhile (podmínka) {\n  // blok kódu, který se má provést\n}\nV následujícím příkladu se kód v cyklu bude spouštět stále dokola, dokud bude proměnná i menší než 5:\nPříklad\nint i = 0;\nwhile (i &lt; 5) {\n  System.out.println(i);\n  i++;\n}\nPoznámka: Nezapomeňte zvýšit proměnnou použitou v podmínce, jinak cyklus nikdy neskončí!\n\n\nSmyčka Do/While\nCyklus do/while je variantou cyklu while. Tento cyklus provede blok kódu jednou, než zkontroluje, zda je podmínka pravdivá, a pak bude cyklus opakovat tak dlouho, dokud bude podmínka pravdivá.\nSyntaxe\ndo {\n  // blok kódu, který se má provést\n}\nwhile (podmínka);\nNásledující příklad používá cyklus do/while. Cyklus se vždy provede alespoň jednou, i když je podmínka nepravdivá, protože blok kódu se provede před testováním podmínky:\nPříklad\nint i = 0;do {\n  System.out.println(i);\n  i++;\n}\nwhile (i &lt; 5);\nNezapomeňte zvýšit proměnnou použitou v podmínce, jinak cyklus nikdy neskončí!"},"PRG/Základní-info-o-PRG/Assembler":{"title":"Assembler","links":[],"tags":[],"content":"Assembler\n\nZkráceně označováno ASM\nAssembler = jazyk symbolických adres\n\n\ngenerace kódu\n\n\nÚzce svázaný se strojovým kódem\n\nKaždá instrukce (kombinace 0 a 1) strojového kódu má\nodpovídající slovní označení (kód) → nemusíme si pamatovat čísla\n\n\nInstrukce jsou poté přeloženy opět do strojového kódu, který procesor vykoná\nCo čip, to jiná sada instrukcí\n"},"PRG/Základní-info-o-PRG/Programovací-jazyk":{"title":"Programovací jazyk","links":["PRG/Java/Java","PRG/Základní-info-o-PRG/Assembler","PRG/Základní-info-o-PRG/Strojový-kód"],"tags":[],"content":"Programovací jazyk\n\n\n\ngenerace kódu\n\n\nČísla jsou vnímána již jako proměnné, zdrojový kód připomíná matematický zápis → vysoká čitelnost kódu\nJazyky dělené podle způsobu překladu a spuštění (toto členění není absolutní):\n\nKompilované jazyky\nInterpretované jazyky\nJazyky s virtuálním strojem\n\n\n\nDělení dle způsobu překladu\nKompilované jazyky\n\nJazyk, kterému člověk rozumí\nZdrojový kód se překládá do strojového kódu, aby ho procesor mohl spustit → zajišťuje překladač (kompiler)\nKód se překládá celý najednou a teprve poté se vykoná\nPříklady jazyků: C, C++, Pascal, Delphi\n\nVýhody\n\nRychlost\nNepřístupnost zdrojového kódu\n\nProgram se šíří již přeložený, bez zdrojového kódu nelze měnit\n\n\nSnadné odhalení chyb ve zdrojovém kódu\n\nPokud zdrojový kód obsahuje chybu, při kompilaci proces spadne a objeví se chybové hlášení\n\n\n\nNevýhody\n\nZávislost na platformě\n\nPlatforma = procesor + operační systém\n\n\nNemožnost editace\n\nJakmile se program jednou zkompiluje do strojového kódu, nelze ho editovat jinak, než opětovnou kompilací\n\n\nMemory management\n\nMůžeme se setkat s přetečením paměti (tj. chceme uložit více dat, než na kolik máme místo)\nTyto jazyky obvykle nemají automatickou správu paměti\n\n\n\nInterpretované jazyky\n\nMísto kompilátoru se používá interpret → nepřekládá celý program najednou, ale pouze tu část, která je v danou chvíli potřeba\nPřeklad probíhá během běhu programu po instrukcích (po jednotlivých řádcích kódu) → časově a výkonově náročnější\nPříklad jazyka: BASIC, Perl, Python, shell, Ruby\n\nVýhody\n\nPřenositelnost\n\nPlně přenositelný na různé platformy, pokud existuje vhodný interpret\n\n\nJednodušší vývoj\n\nNemusíme hlídat správu paměti\nNěkdy nemusíme hlídat ani datové typy\n\n\nStabilita\n\nPředchází chybám, které by zkompilovaný program jinak klidně vykonal\n\n\nJednoduchá editace\n\nProgram můžeme vyvíjet po částech\n\n\n\nNevýhody\n\nRychlost\nČasto obtížné hledání chyb\n\nChyby se objeví až při běhu programu\n\n\nZranitelnost\n\nProtože se program šíří v podobě zdrojového kódu, každý do něj může zasahovat nebo krást jeho části\n\n\n\nJazyky s virtuálním strojem\n\nPropojením pozitivních vlastností kompilovaných a interpretovaných jazyků vzniká tzv. virtuální stroj\nV současnosti nejmodernější podoba jazyka pro vývoj aplikací\nPříklady jazyků: Java, C#\nZdrojový kód je kompilátorem přeložen do tzv. mezikódu = bajt-kódu (bytecode) – Tj. strojový (binární) kód, který přímo podporuje objektové programování\nTento bajt-kód je interpretovaný tzv. virtuálním strojem (tj. interpretem = JVM = Java Virtual Machine) do strojového kódu, který procesor vykoná\n\nVýhody\n\nOdhalení chyb ve zdrojovém kódu\n\nDíky kompilaci do bajtkódu odhalíme chyby ve zdrojovém kódu\n\n\nStabilita\n\nInterpret zastaví proces před vykonáním nebezpečné operace a upozorní na chybu\n\n\nJednoduchý vývoj\n\nMáme k dispozici různé knihovny, správa paměti je hlídaná za nás\n\n\nSlušná rychlost\nMálo zranitelný kód\n\nAplikace se šíří jako zdrojový kód v bajtkódu, není tedy úplně jednoduše lidsky čitelná\n\n\nPřenositelnost\n\nNižší a Vyšší programovací jazyky\n\nDo skupiny vyšších jazyků dnes v podstatě patří všechny jazyky kromě Assembler a strojového kódu\n\nProcedurální a Neprocedurální programovací jazyky\nProcedurální\n\npopisuje výpočet pomocí posloupností příkazů a určuje přesný postup (algoritmus), jak danou úlohu řešit\nStrukturované\nObjektově orientované\nPř.: C, C++, C#, Java, Python, …\nZpracovávané údaje mají formu datových objektů různých typů, které jsou v programu reprezentovány pomocí proměnných resp. konstant\nProgram obsahuje deklarace a příkazy\nDeklarace definují význam jmen (identifikátorů)\nPříkazy předepisují akce s datovými objekty nebo způsob řízení výpočtu\n\nNeprocedurální\n\nprogramování pomocí definic co se dělat má a ne jak se to má dělat\nFunkcionální\nLogické\n\nFunkcionální jazyky\n\nvše popisuje pomocí funkcí (často matematických)\nčasto neexistují proměnné Javy, program je soustavou funkcí, které pracují se seznamy prvků\nzpůsob programování je blízký klasické matematice\nZřetězené funkce postupně upravující data\nVe velké míře je uplatněna rekurze (funkce volá sama sebe)\nPř.: Lisp, Haskell, Miranda, …\n\nLogické jazyky\n\npopisují daný problém pomocí logických výroků\nprogramu zadáme klauzule (pravidla), vztahy a vstupní data, které dále využívá k řešení problému\ni zde se ve velké míře uplatňuje rekurze\npoužívají se k tvorbě umělé inteligence, k praktickému programování nejsou využitelné\nnejznámější zástupce je jazyk Prolog\nPř. Program v Prologu pro zjištění většího z čísel\n"},"PRG/Základní-info-o-PRG/Strojový-kód":{"title":"Strojový kód","links":[],"tags":[],"content":"Strojový kód\n\n\n\ngenerace kódu\n\n\ntvoří nuly a jedničky - kombinace odpovídají různým instrukcím procesoru\nProcesor PC vykonává jen omezené množství jednoduchých instrukcí v podobě sekvence bitů → v podobě čísel (obvykle hexadecimální tvar)\nInstrukce jsou tak elementární, že umožňují pouze např. načtení hodnoty z paměti do registru, sečtení hodnoty v registru s hodnotou v jiném registru apod.\nVelmi náročné – programátoři si museli pamatovat sekvenci nul a jedniček\nInstrukce se CPU předloží v binární podobě → extrémně nečitelné a závislost na instrukční sadě CPU\nKaždý program ale musí být nakonec do tohoto jazyka přeložen, aby mohl být spuštěn\n"},"PRG/Základní-info-o-PRG/Syntax-a-sématika":{"title":"Syntax a sématika","links":[],"tags":[],"content":"Syntaxe a sémantika jazyka\nSyntaxe\n\nSouhrn pravidel udávajících přípustné tvary dílčích konstrukcí a celého programu\nJednodušší na odhalení → většina pokročilejších programovacích prostředí dokáže chybu odhalit\n\nSémantika\n\nUdává význam jednotlivých konstrukcí\nTěžší na odhalení → většinou se projeví spadnutím programu, chybným výstupem, předčasným ukončením apod.\n"},"index":{"title":"Xelitky","links":[],"tags":[],"content":"Xelitky\nXelovy  IT poznámky na maturitu\n\nPoznámky z IT na přípravu k maturitě roku 2024\nPoznámky jsou tvořené v programu Obsidian.\n"}}